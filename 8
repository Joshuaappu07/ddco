a)SR Flip-flop
Verilog code
module sr_ff (s, r, clk, q, qb);
input s, r, clk;
output reg q, qb;
always@(posedge clk)
begin
  case({s,r})
    2'b00: begin q = q; qb=qb; end
    2'b01: begin q = 1‘b0; qb=1’b1; end
    2'b10: begin q = 1‘b1; qb=1’b0; end
    2'b11: begin q = 1‘bx; qb=1’bx; end
  endcase
end
endmodule

Testbench code
module sr_tb;
reg s,r,clk;
wire q,qb;
sr_ff uut(.s(s), .r(r), .clk(.clk), .q(q), .qb(qb));
initial begin
  clk=0;
  forever #50 clk=~clk;
end
initial begin
  s=0; r=1; #100;
  s=0; r=0; #100;
  s=1; r=0; #100;
  s=1; r=1; #100;
  $finish();
end
endmodule

b)JK Flip-flop
Verilog code
module jk_ff (j, k, clk, q, qb);
input j, k, clk;
output reg q, qb;
always @ (posedge clk)
begin
  case ({j,k})
    2'b00 : begin q = q; qb=qb; end
    2'b01 : begin q = 1’b0; qb=1’b1; end
    2'b10 : begin q = 1’b1; qb=1’b0; end
    2'b11 : begin q = ~q; qb=~qb; end
  endcase
endmodule

Testbench code
module jk_tb;
reg j, k, clk;
wire q, qb;
jk_ff uut(.j(j), .k(k), .clk(.clk), .q(q), .qb(qb));
initial begin
  clk=0;
  forever #50 clk=~clk;
end
initial begin
  j=0; k=1; #100;
  j=0; k=0; #100;
  j=1; k=0; #100;
  j=1; k=1; #100;
  $finish();
end
endmodule

c)D Fllip-flop
Verilog code
module d_ff(clk, d, q, qb);
input clk, d;
output reg q;
always @ (posedge clk)
  begin
    q = d; qb=~q;
  end
endmodule

Testbench code
module d_tb;
reg d, clk;
wire q, qb;
d_ff UUT(.d(d), .clk(clk), .q(q), .qb(qb));
initial begin
  clk = 0;
  forever #50 clk=~clk;
end
initial begin
  d = 1'b0; #100
  d = 1'b1; #100
  $finish();
end
endmodule
